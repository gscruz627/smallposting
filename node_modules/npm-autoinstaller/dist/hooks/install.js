'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.installHooks = exports.copyHooks = exports.replaceHookInString = exports.hasAlreadyOtherHooks = exports.isAutoinstallerHook = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _paths = require('../paths');

var _log = require('../log');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hooks = ['post-checkout', 'post-merge', 'post-rewrite'];
var infoString = 'this file has been automatically generated, please do not edit it';

/**
 * is autoinstaller hook
 *
 * @desc    check if an existing git hook is a previously installed
 *          npm-autoinstaller hook
 * @param   {string} hook - name of the git hook
 * @return  {boolean}
 */
var isAutoinstallerHook = exports.isAutoinstallerHook = function isAutoinstallerHook(hook) {
  var data = _fs2.default.readFileSync((0, _paths.getGitHooksPath)() + '/' + hook, 'utf8');
  var lines = data.split("\n");

  return lines.length > 2 && lines[2].startsWith('# npm-autoinstaller');
};

/**
 * has already other hooks
 *
 * @desc    checks if there are already git hooks installed which are not
 *          from this package
 * @return  {boolean}
 */
var hasAlreadyOtherHooks = exports.hasAlreadyOtherHooks = function hasAlreadyOtherHooks() {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = hooks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var hook = _step.value;

      if (_fs2.default.existsSync((0, _paths.getGitHooksPath)() + '/' + hook)) {
        if (isAutoinstallerHook(hook)) {
          _fs2.default.unlinkSync((0, _paths.getGitHooksPath)() + '/' + hook);
          continue;
        }

        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
};

/**
 * replace hook in string
 *
 * @desc  replaces the {HOOK} placeholder in a string
 * @param {string} content - string in which the hook should get replaced
 * @param {string} hook - name of the git hook
 * @return {string}
 */
var replaceHookInString = exports.replaceHookInString = function replaceHookInString(content, hook, relativePath) {
  var replacedString = content.replace(/\{HOOK\}/g, hook);
  replacedString = replacedString.replace(/\{INFO\}/g, infoString);
  replacedString = replacedString.replace(/\{PATH}/g, relativePath);
  return replacedString;
};

/**
 * copy hooks
 *
 * @desc  copyies the hook template over to the git hooks directory
 */
var copyHooks = exports.copyHooks = function copyHooks() {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = hooks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var hook = _step2.value;

      try {
        var relativePath = _path2.default.relative((0, _paths.getGitHooksPath)(), __dirname);
        var content = _fs2.default.readFileSync(_paths.packagePath + '/dist/hooks/hook-template.sh', 'utf8');
        _fs2.default.writeFileSync((0, _paths.getGitHooksPath)() + '/' + hook, replaceHookInString(content, hook, relativePath));
        _fs2.default.chmodSync((0, _paths.getGitHooksPath)() + '/' + hook, '755');
      } catch (e) {
        (0, _log.separator)();
        (0, _log.error)('npm-autoinstaller could not be installed:');
        (0, _log.error)('could not copy git hooks!');
        (0, _log.error)(e);
        (0, _log.separator)();
        return;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
};

/**
 * install hooks
 *
 * @desc  installs all available git hooks
 * @param {function} callback - optional callback function
 */
var installHooks = exports.installHooks = function installHooks(callback) {
  var gitHooksPath = (0, _paths.getGitHooksPath)();

  if (!gitHooksPath) {
    (0, _log.separator)();
    (0, _log.error)('npm-autoinstaller could not be installed:');
    (0, _log.error)('git hooks directory not found!');
    (0, _log.error)('this directory is most likely not a git repository.');
    (0, _log.separator)();
  } else {
    _fs2.default.lstat(gitHooksPath, function (err, stats) {
      if (err || !stats.isDirectory()) {
        (0, _log.separator)();
        (0, _log.error)('npm-autoinstaller could not be installed:');
        (0, _log.error)('git hooks directory not found!');
        (0, _log.error)('this directory is most likely not a git repository.');
        (0, _log.separator)();
      } else if (hasAlreadyOtherHooks()) {
        (0, _log.separator)();
        (0, _log.error)('npm-autoinstaller could not be installed:');
        (0, _log.error)('it seems like you already have some git hooks installed.');
        (0, _log.error)('if you are using (or have used) another git-hooks package, please read:');
        (0, _log.error)('https://github.com/cyrilwanner/npm-autoinstaller/blob/master/MIGRATING.md'.underline);
        (0, _log.separator)();
      } else {
        copyHooks();
      }

      if (typeof callback === 'function') {
        callback();
      }
    });
  }
};