'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetGitHooksPath = exports.getGitHooksPath = exports.rootPath = exports.packagePath = undefined;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var packagePath = exports.packagePath = _path2.default.resolve('' + __dirname + _path2.default.sep + '..');
var rootPath = exports.rootPath = _path2.default.resolve(__dirname).split(_path2.default.sep + 'node_modules')[0];

var cachedGitHooksPath = void 0;

/**
 * find the path where githooks are stored for the current git repository
 *
 * @return  {string}
 */
var getGitHooksPath = exports.getGitHooksPath = function getGitHooksPath() {
  if (cachedGitHooksPath) {
    return cachedGitHooksPath;
  }

  var prevPath = rootPath;
  var maxIterations = 10;

  do {
    if (_fs2.default.existsSync('' + prevPath + _path2.default.sep + '.git' + _path2.default.sep + 'hooks')) {
      cachedGitHooksPath = '' + prevPath + _path2.default.sep + '.git' + _path2.default.sep + 'hooks';
      return cachedGitHooksPath;
    }

    var nextPath = _path2.default.resolve(prevPath, '..');

    // abort when reached the top most folder or only gets installed as a dependency of another module
    if (nextPath === prevPath || _path2.default.basename(nextPath) === 'node_modules') {
      return null;
    }

    prevPath = nextPath;
    maxIterations--;
  } while (maxIterations >= 0);

  return null;
};

/**
 * reset the cached git hooks path
 */
var resetGitHooksPath = exports.resetGitHooksPath = function resetGitHooksPath() {
  cachedGitHooksPath = null;
};