'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _child_process = require('child_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _input = require('./input');

var _log = require('./log');

var _paths = require('./paths');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * package manager class
 */
var Manager = exports.Manager = function () {
  function Manager(name, config) {
    _classCallCheck(this, Manager);

    this.name = name;

    if (config && typeof config.command !== 'undefined' && typeof config.files !== 'undefined') {
      this.loadFromConfig(config);
    } else {
      throw new Error('can not load manager from config');
    }
  }

  /**
   * load from config
   *
   * @desc  load the configuration for the manager
   */


  _createClass(Manager, [{
    key: 'loadFromConfig',
    value: function loadFromConfig(config) {
      this.action = config.do;
      this.command = config.command;
      this.files = Array.isArray(config.files) ? config.files : [config.files];
      this.excludedFolders = config.excludedFolders || [];

      // use the fallback action if the shell is not interactive
      if (this.action === 'ask' && !process.stdout.isTTY) {
        this.action = config.fallback;
      }

      if (typeof this.action === 'undefined') {
        this.action = 'install';
      }
    }

    /**
     * is disabled
     *
     * @desc    check if the manager is currently disabled
     * @return  {boolean}
     */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return !this.action || this.action === 'disabled';
    }

    /**
     * is dependency file
     *
     * @desc    check if the file defines the dependencies of this manager
     * @return  {boolean}
     */

  }, {
    key: 'isDependencyFile',
    value: function isDependencyFile(file) {
      var _this = this;

      return this.files.some(function (managerFile) {
        if (managerFile.startsWith('^')) {
          return file === managerFile.substr(1);
        }

        return ('/' + file.replace(/\\/g, '/')).endsWith('/' + managerFile) && !_this.excludedFolders.some(function (folder) {
          return !!file.match(new RegExp('(^|/|\\\\)' + folder + '(/|\\\\)'));
        });
      });
    }

    /**
     * update
     *
     * @desc  installs the new packages or asks/warns about it, depending on the configured action
     */

  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      var contexts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['.'];

      // check if it is disabled
      if (this.isDisabled()) {
        return;
      }

      contexts.forEach(function (context) {
        var changeInfo = _this2.name + ' packages have changed';

        if (context !== '.') {
          changeInfo += ' (in ' + context + '/)';
        }

        // warn the user that the packages have changed but do nothing
        if (_this2.action === 'warn') {
          (0, _log.warn)(changeInfo + ' but are not updated automatically');
          (0, _log.warn)('you may need to run \'' + _this2.command + '\' manually if your app requires the new versions of the packages');

          // install the packages
        } else if (_this2.action === 'install' || _this2.action === 'update') {
          (0, _log.info)(changeInfo + ', installing the updated packages..');
          _this2.executeCommand(context);

          // ask if the packages should get installed
        } else if (_this2.action === 'ask') {
          (0, _log.info)(changeInfo + ', do you want to install the new versions?');

          if ((0, _input.askForInstall)()) {
            (0, _log.info)('installing updated packages..');
            _this2.executeCommand(context);
          } else {
            (0, _log.info)('updated packages won\'t get installed');
          }
        }
      });
    }

    /**
     * execute command
     *
     * @desc  execute the defined install command
     */

  }, {
    key: 'executeCommand',
    value: function executeCommand(context) {
      try {
        (0, _child_process.execSync)(this.command, {
          cwd: _path2.default.normalize((0, _paths.getGitHooksPath)() + '/../../' + context),
          stdio: 'inherit'
        });
      } catch (e) {
        if (e.toString().indexOf('command not found') >= 0) {
          (0, _log.error)('the command \'' + this.command.split(' ')[0] + '\' could not be found');
          (0, _log.error)('please install it globally or update the install command in the npm-autoinstaller config');
        } else {
          (0, _log.error)(e);
          (0, _log.error)('packages could not be installed');
        }
      }
    }
  }]);

  return Manager;
}();